> This is *under development* and represents only the initial content layout/approximation to what this file will contain for its final version.

<div align=center>
	<img alt="LaMancha_Logo" src="./promo/LaManchaEngine_Logo.svg#svgView(viewBox(35, 480, 1985, 970))" width=360 height=160/>
</div>
<br>
<p align="center">
    <a target="_blank" href="https://github.com/ph0nsy/LaMancha-Engine/network"><img alt="version" src="https://img.shields.io/badge/version-0.0.1-blue.svg?style=flat&labelColor=888888&color=2EA967&logo=github"></a>
     <!--<a target="_blank" href="https://github.com/ph0nsy/LaMancha-Engine/stargazers"><img alt="stars" src="https://img.shields.io/github/stars/ph0nsy/LaMancha-Engine.svg?style=flat&labelColor=888888&color=2EA967&logo=github"></a>-->
     <!--<a target="_blank" href="https://github.com/cocos/LaMancha-Engine/forks"><img alt="forks" src="https://img.shields.io/github/forks/ph0nsy/LaMancha-Engine.svg?style=flat&labelColor=888888&color=2EA967&logo=github"></a>-->
    <a target="_blank" href="./LICENSE"><img alt="license" src="https://img.shields.io/badge/license-MIT-blue.svg?style=flat&labelColor=888888&color=2EA967&logo=github"></a>
</p>

<p align="center">
	<img alt="C++_Tag" src="https://img.shields.io/badge/C++-%2300599C.svg?style=flat-square&logo=c%2B%2B&logoColor=white">
	<img alt="Lua" src='https://img.shields.io/badge/Lua-2C2D72?style=flat-square&logo=lua&logoColor=white'/>
	<img alt="2D_Tag" src="https://img.shields.io/badge/2D-FFFFFF?style=flat-square&colorB=blue">
	<img alt="Lightweight_Tag" src="https://img.shields.io/badge/Lightweight-grey.svg?style=flat-square&color=purple">
</p>

<p align="center">
	<img alt="Linux" src="https://img.shields.io/badge/Linux-FCC624?style=for-the-badge&logo=linux&logoColor=black">
	<img alt="Windows" src="https://img.shields.io/badge/Windows-0078D6.svg?style=for-the-badge&logo=data:image/png%2bxml;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAQAAABecRxxAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfoBh4XDC5gTxF1AAAEt0lEQVR42u3dsQ2DMBCG0TNiJXaApSiyR+YwO6TMDJnjWIAC0lg6vddf88v6WrfMoLqjbc+PssdquuomE4AAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAgAAAAgAIACAAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIACAAAACAAgAIAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIAjDHH2wjlff+6OuJnOgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA+1p2I5T3afvzo3zFYrrq5liNwKXF26jP78AgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAgAIAAAAIACAAIgAlAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEABAAAABAAQAEAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQAEAAAAEABAAQABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAEABAAQAAAAQAGOQHLshFV6K14LgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyNC0wNi0zMFQyMzoxMjo0NiswMDowMOA+OTsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjQtMDYtMzBUMjM6MTI6NDYrMDA6MDCRY4GHAAAAAElFTkSuQmCC&logoColor=white">
</p>

## Overview

**LaMancha Engine** is a lightweight, modular, cross-platform 2D engine written in <img alt="_C++ 17_" align=center src="https://img.shields.io/badge/C++_17-%2300599C.svg?logo=c%2B%2B&logoColor=white"/>, optimized for low-end devices (**R36S**) and modern Linux/Windows systems.

Key features:

- **Lightweight & fast** thanks to minimal heap allocations, `.ini`-based configuration and event-driven architecture.  
- **Event-driven input & gameplay** prevents constant polling.  
- **Cross-platform rendering** via OpenGL ES 2.0+ via GLAD and GLM.  
- **Asynchronous tasks** with threadpool handling asset loading, logging, and profiling.  
- **Custom STL-free [ECS](## "Entity-Component System")**.  
- **<img alt=_Lua_ align=center src='https://img.shields.io/badge/Lua-2C2D72?logo=lua&logoColor=white'/> scripting**.  

## Getting Started

**Clone the repository:**

```bash
git clone https://github.com/ph0nsy/LaMancha-Engine.git
cd LaMancha-Engine
```

**Build the engine (Makefile-based) by running:**

| **Pure <img alt="_C++_" align=center src="https://img.shields.io/badge/C++-%2300599C.svg?logo=c%2B%2B&logoColor=white"/>** | **<img alt="_C++_" align=center src="https://img.shields.io/badge/C++-%2300599C.svg?logo=c%2B%2B&logoColor=white"/> & <img alt=_Lua_ align=center src='https://img.shields.io/badge/Lua-2C2D72?logo=lua&logoColor=white'/>** |
|:--------------:|:----------------:|
| `make`         | `make USE_LUA=1` |

**Test installation by running a demo project:**

```bash
./Builds/Demo
```

**Configure projects by using `/Tools/ProjectConfigurator` or directly modifying `project.ini` and `input.ini` in `/Game/Config/`**

## Technical Info

### Folder Layout:
```
LaMancha-Engine/
â”œâ”€â”€ ðŸ“‚ EngineCore/		â†’ Core subsystems (ECS, Renderer, Input, Assets, Profiler, optional Lua)
â”œâ”€â”€ ðŸ“‚ Game/			â†’ Game logic, scripts, assets, configs
â”œâ”€â”€ ðŸ“‚ ThirdParty/		â†’ Static libraries (spdlog, GLAD, GLM, stb, threadpool, tinyfiledialogs, Lua, etc.)
â”œâ”€â”€ ðŸ“‚ Tools/			â†’ ProjectCreator, ProjectConfigurator, ProjectPackager, ProfilerViewer, AssetPacker
â”œâ”€â”€ ðŸ“‚ Builds/			â†’ Target folder for built projects
â””â”€â”€ main.cpp			â†’ Engine entry point
````

#### Dependencies
| Library | Purpose |
|:---------|:---------|
| **chrono** _(C++ standard)_ | Provides high-resolution timers and time-point utilities for frame timing, delta time, and profiling |
| **glad** | OpenGL (and GLES) function loader; manages runtime loading of API function pointers for cross-platform rendering |
| **glfw** | Lightweight window, input, and OpenGL context management (window creation, keyboard/mouse/joystick handling) |
| **glm** | Header-only math library implementing GLSL-style vector/matrix/quaternion operations for transforms, camera math, and rendering |
| **inih** | INI file parser used for configuration files (`project.ini`, `input.ini`, etc.) â€” simple, dependency-free, and fast |
| **lua (5.4)** | Embedded scripting VM enabling dynamic gameplay logic, runtime debugging, and data-driven entity behavior |
| **miniz** | Single-file zlib-compatible compression/decompression library for handling compressed assets or packed resources |
| **stb** | Collection of public-domain single-header utilities (`stb_image`, `stb_vorbis`, etc.) for texture and audio loading |
| **spdlog** | High-performance asynchronous logging library used for runtime logging, profiling output, and file logs |
| **thread-pool** | Lightweight C++ threadpool for dispatching background tasks (asset streaming, profiling, async GC) |
| **tinyfiledialogs** | Cross-platform file picker and message box utility used in development tools (ProjectConfigurator, AssetPacker) |

Key considerations behind each dependency:
- **Minimal heap usage:** Most libraries are either header-only (glm, stb) or manage memory internally in predictable ways (miniz, tinyfiledialogs). This reduces fragmentation and improves cache efficiency.
- **Cross-platform support:** Libraries like glfw, glad, and tinyfiledialogs provide uniform APIs across Linux and Windows, simplifying development and maintenance.
- **Lightweight and modular:** Each library performs a specific role without introducing heavy frameworks. For example, spdlog focuses on logging only, while lua provides a runtime scripting VM without imposing a GUI layer.
- **Ease of integration:** Single-header or self-contained libraries (inih, stb, miniz) can be directly included without complex build chains, keeping engine builds simple and portable.
- **Tooling support without bloat:** tinyfiledialogs allows for native file dialogs and message boxes in engine tools with negligible footprint, avoiding the need for full GUI frameworks like _ImGui_, which would add rendering overhead. _TinyFileDialogs_ is used for minimal dialogs in tools; _ImGui_ is heavier but required if you want in-engine interactive GUI.
- **Performance-conscious:** Threading, memory access patterns, and asset streaming are designed with low-end CPUs and limited memory in mind. Libraries like thread-pool and spdlog enable asynchronous operations that reduce frame stalls.

> Overall, this dependency selection emphasizes predictable performance, small memory footprint, and simplicity, making the engine suitable for embedded devices and low-end PCs while maintaining flexibility for desktop development.

### Hardware Context:

The Rockchip RK3326 inside the **R36S** is this engine's target for a 4-thread lightweight <img alt="_C++_" align=center src="https://img.shields.io/badge/C++-%2300599C.svg?logo=c%2B%2B&logoColor=white"/> engine with manual memory control and OpenGL compatible rendering since it features:

- **CPU:** Quad-core ARM Cortex-A35 (ARMv8-A) ~1.3 GHz <!-- Low-power but efficient cores, in-order pipeline â†’ Great for parallel lightweight threads (1 per core). Avoids heavy SIMD or CPU-side batching. -->
- **L1 Cache:** 32 KB I + 32 KB D per core <!-- Separate instruction and data cache â†’ Reduces instruction stalls. Code and hot data (ECS components) should be cache-friendly. -->
- **L2 Cache:** 256 KB shared cluster <!-- Common cache for all 4 cores â†’ Moderate size. Thread-local memory zones minimize L2 contention. -->
- **GPU:** Mali-G31 (OpenGL ES 3.2, Vulkan 1.0) <!-- Tile-based deferred renderer â†’ Low driver overhead, low power. Use GLES for rendering; batching and early-Z culling are key. -->
- **RAM:** 1 GB (typically LPDDR3) <!-- Limited but sufficient (~2.1 GB/s bandwidth) â†’ Encourages arena allocators and asset streaming instead of keeping everything loaded. -->
- **Storage:** MicroSD (64 GB) <!-- Slow random access (often 40â€“80 MB/s read) â†’ Asynchronous asset IO thread is essential to avoid stalls. -->
- **No Active Cooling:** Thermal limit is ~2.5 W <!-- Throttling risk if CPU stays >80% â†’ Offload heavy logic or rendering to async threads; maintain ~70% CPU load. -->

> This engine has been developed with the **R36S** and similar low-end systems in mind; this means that, while allowing cross-platform builds is an important goal of the engine, the main focus is this system.

### Thread Model:

| **Subsystem** | **Core Affinity** | **Responsibilities** | **Zone** |
|:--------------|:-----------------:|:--------------------:|:---------|
| **Main Thread** |       Core 0      | Poll input, update timing, execute render pipeline (OpenGL context owner) | `FrameAllocator`, `RenderArena` â€” Transient GPU data (framebuffers, matrices, draw lists); freed every frame |
| **Logic Thread** |       Core 1      | Runs [ECS](## "Entity-Component System") systems, AI, game logic, Lua polling, project manager | `ECS Pools`, `ScriptArena` â€” Game logic, components, Lua variables â€” stable, long-lived memory |
| **Asset Thread** |       Core 2      | Handles asset loading, decompression, background resource prep | `IOArena` â€” Streaming assets â€” often temporary or bulk freed after load |
| **Utility Thread** |       Core 3      | Async spdlog writes, [GC](## "Garbage Collector") sweeps, performance profiling | `LogBuffers`, `GCHeap` â€” Buffers for log messages, small allocations for background [GC](## "Garbage Collector") and profiling data |

<!--Each â€œzoneâ€ is typically managed by one or more allocators (Arena, Frame, or Pool), so that threads can:
- allocate/deallocate without locking
- improve cache locality
- avoid heap fragmentation
- simplify memory cleanup (entire zones can be cleared in one go)

Why This Matters

On the R36S (with its small cache and limited RAM), cache contention and heap locks can become major bottlenecks. Giving each thread its own zone means:
- No cross-thread malloc/free contention
- Predictable memory footprint
- Easier debugging (logs know which zone failed)
- Fast cleanup (zone reset vs. individual frees)

In effect, itâ€™s a manual version of NUMA-aware allocation, scaled down to an embedded device.

Frame Execution Flow
[ Main Thread ]
   â†“ Poll Input (Immediate)
   â†“ Dispatch to Logic Thread
   â†“ Render Previous Frame (OpenGL ES)
   â†“ Present Framebuffer
   â†‘ Wait for logic to signal frame data ready

[ Logic Thread ]
   â†“ Process input events
   â†“ Update ECS, Lua, gameplay
   â†“ Build render command list
   â†“ Signal Main Thread for rendering

[ IO Thread ]
   â†» Load / decode textures, meshes, shaders
   â†» On completion â†’ notify Logic/Main (atomic flag or queue)

[ Utility Thread ]
   â†» Write logs (spdlog async)
   â†» Sample profiler stats
   â†» Incremental garbage collection

This ensures that rendering never stalls waiting on logic or IO, while logic always runs one frame ahead of GPU work.

Synchronization Model
- Lock-free queues (RingQueue<T, N>) for event passing.
- Double-buffered render data (logic builds â†’ render consumes).
- Atomic flags for async signals (asset readiness, frame completion).
- spdlog async sink for thread-safe file logging.
- Condition variables used only during frame synchronization (2 per frame max).
-->

<!-- When CPU time allows, the Logic Thread can enqueue short tasks to a 2-thread worker pool (light culling or physics jobs). -->

> Each *Zone* is a thread-local memory region managed by custom allocators (Arena, Pool, or Frame). This avoids cross-thread heap contention, improves cache locality, and allows O(1) cleanup.

#### Frame Execution Flow

- **[Main Thread]**  â†’ Poll Input 		â†’ Dispatch Logic 	â†’ Render â†’ Present
- **[Logic Thread]** â†’ Update [ECS](## "Entity-Component System")/Lua 	â†’ Build Commands	â†’ Signal Render
- **[IO Thread]**    â†’ Load Assets 		â†’ Notify Logic
- **[Utility]**      â†’ Log + Profile + Incremental [GC](## "Garbage Collector")

> Rendering never waits for logic or I/O; logic runs one frame ahead of GPU work.

<!-- 
An Arena Allocator (also known as a Region or Linear Allocator) preallocates a large, contiguous block of memory and doles it out sequentially. There are no individual frees â€” you can only reset the entire arena when all allocations become invalid. Advantages: 
- O(1) allocation
- No fragmentation
- Cache-friendly
- Very small code footprint 
- Perfect for transient data (e.g., decompression buffers, frame-local allocations) 
Disadvantages: 
- Cannot free individual allocations
- Must know approximate usage pattern
Example:
```cpp
struct Arena {
    uint8_t* base;
    size_t size;
    size_t offset;
};

void* arena_alloc(Arena& a, size_t bytes) {
    assert(a.offset + bytes <= a.size);
    void* ptr = a.base + a.offset;
    a.offset += bytes;
    return ptr;
}

void arena_reset(Arena& a) {
    a.offset = 0;
}
```
References:
â€œGame Engine Architectureâ€ by Jason Gregory (3rd Edition, Chapter 15)
Casey Muratori â€” Handmade Hero: Day 30 - Linear Allocators
Naughty Dog Tech Blog: Memory Management in Uncharted 4 (2016)

A Pool Allocator (or Free List Allocator) divides memory into equal-sized chunks and recycles them efficiently.
This pattern is ideal for systems like an Entity-Component System, where components of a given type all have the same size (this avoids STL and uses a small custom ring buffer instead). Advantages: 
- O(1) alloc/dealloc
- Predictable memory footprint
- Eliminates heap fragmentation
- Perfect for frequently created/destroyed small objects (ECS components, tasks, entities) 
Disadvantages: 
- Wastes memory if object sizes vary
- Initialization overhead (need to pre-fill free list)
Example:
```cpp
struct Pool {
    uint8_t* memory;
    size_t element_size;
    std::vector<void*> free_list;
};

void* pool_alloc(Pool& p) {
    if (p.free_list.empty()) return nullptr;
    void* ptr = p.free_list.back();
    p.free_list.pop_back();
    return ptr;
}

void pool_free(Pool& p, void* ptr) {
    p.free_list.push_back(ptr);
}
```
References:
Game Programming Patterns â€” â€œObject Poolâ€ by Robert Nystrom (2014)
Unreal Engine Memory Management Overview
id Tech 4 Source Code â€” idBlockAlloc / idDynamicBlockAlloc

A Frame Allocator is a variant of the Arena pattern that resets once per frame.
Itâ€™s typically used for transient per-frame allocations such as temporary vertex buffers, culling data, or camera matrices. Each frame, the offset pointer is reset. All objects allocated during that frame are implicitly freed. Advantages: 
- Zero cleanup cost: O(1) reset
- Great temporal locality
- Predictable frame-time performance
- Ideal for data that only lives one frame
Example:
```cpp
struct FrameAllocator : public Arena {
    void begin_frame() { offset = 0; }
};
```
References:
Insomniac Games GDC 2019: â€œPractical Memory Management for Gamesâ€
Naughty Dog: â€œFrame-Based Allocationsâ€ in The Last of Us (GDC 2014)
EAâ€™s Frostbite Engine Technical Overview (DICE, 2018)

A Memory Zone is a high-level abstraction representing one or more allocators dedicated to a subsystem or thread.
Each zone manages its own allocators (e.g., one Arena + one Pool) and ensures no cross-thread heap contention. Each thread might own one MemoryZone, isolating memory access and making cleanup deterministic. This pattern echoes NUMA-aware design, scaled down for embedded or console systems. 
References:
id Softwareâ€™s â€œZone Memory Allocatorâ€ (DOOM 1993 Source Code) â€” this is where the term zone originated.
Unreal Engine: Memory Zones and Pools (UE5 Source, FMallocBinned2)
â€œMemory Management in Gamesâ€ â€” GDC Vault 2018, Insomniac Games
-->

<!-- 
Why This Matters for the R36S:
**Hardware Constraint**					â†’ **Design Response**
1 GB LPDDR3 RAM							â†’ Allocators avoid heap fragmentation, improving memory predictability
256 KB shared L2 Cache					â†’ Thread-local zones prevent cache thrashing
In-order ARM Cortex-A35 cores 			â†’ Sequential access patterns from arenas/pools improve CPU efficiency
No hardware cooling						â†’ Minimizing CPU stall time reduces power and heat
MicroSD storage (slow random access) 	â†’ Asynchronous IO with streaming arenas prevents frame stalls

Performance Implications (Empirical + Theoretical):
**Metric**						â†’ **malloc/new**	â†’	**Custom Allocators**
Allocation latency				â†’	0.5â€“5 Âµs		â†’	<0.05 Âµs
Deallocation latency			â†’	0.5â€“5 Âµs		â†’	<0.01 Âµs
Cache miss rate (ECS update)	â†’	~20%			â†’	<10%
Heap fragmentation				â†’	High			â†’	None
Frame variance					â†’	Â±3 ms			â†’	<0.5 ms
Memory reuse efficiency			â†’	60â€“70%			â†’	>95%

Summary:
Allocator	â†’ Lifetime						â†’ Typical Usage					â†’ Thread Safety		â†’ Free Model	â†’ Reset Time	â†’ Example Engine
Arena		â†’ Medium						â†’ Streaming, temporary buffers	â†’ Thread-local		â†’ All-at-once	â†’ O(1)			â†’ Doom 3, Uncharted 4
Pool		â†’ Long							â†’ ECS components, small objects	â†’ Thread-local		â†’ Individual	â†’ O(1)			â†’ Unreal, idTech 5
Frame		â†’ Short (per frame) 			â†’ Rendering, transient math		â†’ Thread-local		â†’ All-at-once	â†’ O(1/frame)	â†’ Frostbite, Naughty Dog
Zone		â†’ Permanent (thread lifetime) 	â†’ Subsystem memory grouping		â†’ Thread-exclusive	â†’ N/A			â†’ N/A			â†’ Unity DOTS (chunk allocator)

Sources: 
- Gregory, Jason. Game Engine Architecture (3rd Ed.) â€“ CRC Press, 2018.
- Muratori, Casey. Handmade Hero â€” Linear Allocators Lecture (2015).
- Naughty Dog: Memory System Design in Uncharted 4 â€” GDC 2016.
- Insomniac Games: Practical Memory Management for Games â€” GDC 2019.
- Robert Nystrom: Game Programming Patterns â€” â€œObject Poolâ€ Chapter, 2014.
- id Software: DOOM (1993) Source Code â€” z_zone.c (first use of â€œzone allocatorâ€).
- EA DICE: Frostbite Architecture Overview (2018).
- Unreal Engine Source: FMallocBinned2 (Memory Pooling Implementation).
-->

#### Startup Flow

```
â†’ Init Logger (async spdlog)
â†’ Init Memory Zones (Arena, Pool, Frame)
â†’ Init GC and register allocators
â†’ Init Input (event-driven, device scan)
â†’ Init Renderer (GL context + shaders)
â†’ Init ECS
â†’ Init Lua VM (if enabled)
â†’ Load Project (from project.ini)
â†’ Enter Main Loop
```

#### Shutdown Flow

```
â†’ Flush and Free Logger
â†’ Shutdown ECS
â†’ Shutdown Garbage Collector
â†’ Release Allocators and Memory Zones
```

### Expected Performance:

#### CPU & FPS

| **Operation** | **Duration** | **Notes** |
|:--------------|:-------------|:---------:|
| Input Poll | 50â€“100 Âµs | Direct memory read or ioctl |
| [ECS](## "Entity-Component System") Update (1k entities) | 1.5â€“2.0 ms | Optimized SoA layout |
| Lua Poll | 0.2â€“0.4 ms | Depends on script complexity |
| Render Submit (100 draw calls) | 4â€“6 ms | OpenGL ES 3.2 calls |
| Frame Allocator Reset | <0.1 ms | O(1) pointer reset |
| Logging Write (async) | <0.05 ms | Fully buffered |
| Garbage Collector | 0.5â€“1 ms (background) | Fully Asynchronous |
| Asset Streaming (IO Thread) | Background | Non-blocking |

If the total frame budget for 60 fps is 16.6 ms and the average frame time is between 9 and 12 ms, this means the theoretical max fps ranges from 85 to 95 fps (VSync-off, GPU-bound).

#### Memory Footprint

| **Subsystem** | **Allocated** | **Notes** |
|:--------------|:--------------|:---------:|
| Core Engine | 1â€“2 MB | Includes [ECS](## "Entity-Component System"), logging, configs |
| Renderer (OpenGL ES buffers) | 3â€“5 MB | Framebuffers, shaders, meshes |
| Assets (Arena) | 20â€“40 MB | Textures, models, audio (varies) |
| Garbage Collector | 1â€“2 MB | Metadata, handle tables, <img alt=_Lua_ align=center src='https://img.shields.io/badge/Lua-2C2D72?logo=lua&logoColor=white'/> [VM](## "Virtual Machine") |
| Temporary (Frame allocator) | 1â€“2 MB | Per-frame buffers |
| Total Typical Runtime | 30â€“50 MB RAM | - |

> The lightweight [GC](## "Garbage Collector") is an engine-wide incremental garbage collector that reclaims memory from [ECS](## "Entity-Component System"), Lua [VM](## "Virtual Machine"), and asset handles without introducing stalls.

#### Memory Bandwidth & Cache Utilization

| **Metric** | **Expected** | **Notes** |
|:-----------|:-------------|:---------:|
| L1 Hit Rate | >90 % | Small working sets ([ECS](## "Entity-Component System"), input) fit easily |
| L2 Hit Rate | 70â€“80 % | Slight contention between 4 threads |
| Memory Bandwidth | <200 MB/s | Below LPDDR3 limit (~2.1 GB/s) |
| [GC](## "Garbage Collector") / Logging | <1 % frame time | Mostly background activity |

> This section is purely theoretical until there is enough implemented to actually test for benchmarks.

#### Documentation

You can find the full documentation [here](https://github.com/ph0nsy/LaMancha-Engine/wiki).

## FAQ

**Q: Can I create a game without touching engine code?**

**A:** Yes, engine provides mechanics, not rules â€” all gameplay logic is added in `/Game/Systems/` (<img alt="_C++_" align=center src="https://img.shields.io/badge/C++-%2300599C.svg?logo=c%2B%2B&logoColor=white"/>) or `/Game/Scripts/` (<img alt="_Lua_" align=center src="https://img.shields.io/badge/Lua-2C2D72?logo=lua&logoColor=white"/>).

**Q: How lightweight is it?**

A: Event-driven architecture reduces CPU overhead and simplifies game logic. INI-based configuration keeps memory footprint low. Typical runtime footprint: ~30â€“50 MB on **R36S**; engine startup <1 second cold boot, <300ms warm boot.

**Q: Is <img alt=_Lua_ align=center src='https://img.shields.io/badge/Lua-2C2D72?logo=lua&logoColor=white'/> mandatory?**

**A:** No â€” <img alt=_Lua_ align=center src='https://img.shields.io/badge/Lua-2C2D72?logo=lua&logoColor=white'/> is optional. You can run the engine and games entirely in <img alt="_C++_" align=center src="https://img.shields.io/badge/C++-%2300599C.svg?logo=c%2B%2B&logoColor=white"/>'s [ECS](## "Entity-Component System") and systems.

### Licenses

Resources created for the LaMancha Engine can be used under the following licenses:

|  Resources  |    License   |
|:------------|:------------:|
|    Code     |      MIT     |
|    Art      | CC BY-SA 4.0 |
|    Audio    | CC BY-ND 4.0 |

## Donate

<!-- Update with Ko-Fi link -->
